# Classes to Skip During Code Generation
# This file defines which AUTOSAR classes should NOT be generated by tools/generate_models.py
#
# Classes listed here are manually maintained and should not be overwritten by the generator.
#
# Common reasons to skip a class:
# - Base classes that require custom serialization logic (e.g., ARObject, AUTOSAR)
# - Classes with complex decorator patterns that can't be auto-generated
# - Classes with hand-optimized implementations

skip_classes:
  # Root AUTOSAR element - manually maintained
  - "AUTOSAR"

  # Base ARObject class - implements reflection-based serialization framework
  - "ARObject"

  # ARRef class - represents AUTOSAR references with DEST attribute
  - "ARRef"

  # Abstract base class for SwBaseType - requires custom handling
  - "BaseType"

  # CompuMethod is a complex class with custom serialization logic with compuInternalToPhys
  - "CompuMethod"
  - "Compu"
  - "CompuScales"
  - "CompuScale"
  - "CompuConst"
  - "CompuConstTextContent"

  # ARPackage requires custom handling for long_name attribute which contains language-specific elements
  - "ARPackage"

  # LanguageSpecific requires custom handling - L should be an attribute, not a child element
  - "LanguageSpecific"
  # LLongName, LPlainText, LVerbatim, LOverviewParagraph now auto-generated with @language_abbr decorator
  - "LParagraph"
  - "MixedContentForUnitNames"

  # MultiLanguage classes require custom handling for l_prefix pattern (L-10 elements)
  - "MultiLanguagePlainText"
  - "MultiLanguageParagraph"
  - "MultiLanguageVerbatim"
  - "MultilanguageLongName"

  # Item requires custom serialization - item_contents (DocumentationBlock) is serialized as direct children of ITEM, not wrapped in ITEM-CONTENTS
  - "Item"

  # DocumentationBlock requires custom serialization - handles L-1 through L-10 language-specific elements (P paragraphs)
  - "DocumentationBlock"

  # BswModuleClientServerEntry requires custom serialization for REF-CONDITIONAL wrapper pattern
  - "BswModuleClientServerEntry"

# Force TYPE_CHECKING Imports
# These types will always be imported inside TYPE_CHECKING blocks to prevent circular imports.
# This is needed when the automatic circular import detection doesn't catch all cases,
# or when you want to explicitly declare that a type should use TYPE_CHECKING.
#
# Format: mapping from class name to list of attribute types that should use TYPE_CHECKING
# Use "*" to force all imports of a type into TYPE_CHECKING regardless of which class imports it.
#
# Example:
#   force_type_checking_imports:
#     # Always import AbstractImplementationDataType in TYPE_CHECKING block
#     "AbstractImplementationDataType": "*"
#     # When SwDataDefProps imports these types, use TYPE_CHECKING
#     "SwDataDefProps":
#       - "AbstractImplementationDataType"
#       - "ApplicationPrimitiveDataType"
#
force_type_checking_imports:
  # SwDataDefProps has circular import with AbstractImplementationDataType
  # The chain: SwDataDefProps -> AbstractImplementationDataType -> AutosarDataType -> SwDataDefProps
  "AbstractImplementationDataType": "*"
  
  # SwDataDefProps is imported by AutosarDataType, creating a circular chain
  # The chain: AutosarDataType -> SwDataDefProps -> AbstractImplementationDataType -> AutosarDataType
  "SwDataDefProps": "*"
  
  # ApplicationPrimitiveDataType creates a circular chain with AutosarDataType
  # The chain: AutosarDataType -> SwDataDefProps -> ApplicationPrimitiveDataType -> ApplicationDataType -> AutosarDataType
  "ApplicationPrimitiveDataType": "*"
  
  # ValueSpecification may have circular imports with various types
  "ValueSpecification": "*"
