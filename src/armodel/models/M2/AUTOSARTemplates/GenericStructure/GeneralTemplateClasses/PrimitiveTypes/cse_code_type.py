"""CseCodeType AUTOSAR primitive type.

References:
  - AUTOSAR_CP_TPS_SoftwareComponentTemplate.pdf (page 110)
  - AUTOSAR_FO_TPS_GenericStructureTemplate.pdf (page 165)

JSON Source: packages/M2_AUTOSARTemplates_GenericStructure_GeneralTemplateClasses_PrimitiveTypes.primitives.json"""

from __future__ import annotations
from typing import TYPE_CHECKING, Optional
import xml.etree.ElementTree as ET

from armodel.models.M2.AUTOSARTemplates.GenericStructure.GeneralTemplateClasses.PrimitiveTypes.ar_primitive import ARPrimitive

# This primitive represents an ASAM CSE (Codes for Scaling Units) based on the definition in the ASAM-MCD-2MC-ASAP2 specification. The particular semantics is specified in [TPS_GST_00354]. Tags: xml.xsd.customType=CSE-CODE-TYPE-STRING xml.xsd.type=unsignedInt Table 4.15: CseCodeType ARElement AtpBlueprint AtpBlueprintable AtpType PortInterface + serviceKind: ServiceProviderEnum [0..1] «atpVariation» + isService: Boolean [0..1] AtpStructureElement MultidimensionalTime TriggerInterface +trigger Trigger Identifiable +triggerPeriod + cseCode: CseCodeType [0..1] 0..* 0..1 + cseCodeFactor: Integer [0..1] + swImplPolicy: SwImplPolicyEnum [0..1] Figure 4.7: Trigger of a TriggerInterface As illustrated in Figure 4.7, a TriggerInterface is composed of Trigger. [TPS_SWCT_01198] Period for periodic triggering (cid:100)A Trigger can optionally de- fine a period for periodic triggering. It is expressed via the meta-class Multidi- mensionalTime in terms of time or angle. Note that the main use case for this is 110 of 1228 Document ID 62: AUTOSAR_CP_TPS_SoftwareComponentTemplate Software Component Template AUTOSAR CP R23-11 to specify the properties if the trigger is coming from the Basic Software e.g. from a Complex Driver, it is not used as an input for the RTE generator.(cid:99)(RS_SWCT_02030) Apart from this, a TriggerInterface does not define any timing information (e.g. how quickly the source expects a reaction of the sinks). This is property of the timing information in the templates. [constr_1104] Trigger communication shall not implement an n:1 pattern (cid:100)An RPortPrototype typed by a TriggerInterface shall not be connected to Port- Prototypes typed by TriggerInterfaces such that a given Trigger in the Trig- gerInterface of the RPortPrototype is connected to more than one compatible (see [constr_1081], [constr_1082], and [constr_1251]) Trigger in the TriggerIn- terfaces of the connected PortPrototypes at the time when the RTE is generated.(cid:99)() [constr_1104] boils down to the rule that trigger communication shall not be imple- mented an n:1 (where n > 1) scenario. This condition shall be observed (in a similar way as it is observed for individual dataElements in a sender/receiver communication) on the basis of individual Trig- gers rather than the connection between entire PortPrototypes. Please note that the constraint applies for connections created by AssemblySwCon- nectors and DelegationSwConnectors in the same way. This is the reason why [constr_1104] does not get more specific about the nature of the PortPrototypes on opposite end of the connection to the RPortPrototype. To be clear, the n:1 (where n > 1) scenario is not supported for trigger communication because there is no active use case for it. [TPS_SWCT_01199] Queued processing of Triggers (cid:100)It may happen that at least tentatively a Trigger source fires Triggers faster than they can be processed on the side of the Trigger sink. To support this use case it is possible to process trigger event communication in a queued manner. In this case the Triggers are added to a queue from where the foremost trigger is dequeued and processed when the processing of the current Trigger is done. Please note that the queue size is not subject to definition in the scope of this document. The actual queue size is defined during the process of RTE configuration. The specification of whether a Trigger is subject to queued processing is controlled by the attribute Trigger.swImplPolicy.(cid:99)() [constr_1169] Allowed values for Trigger.swImplPolicy (cid:100)The only allowed val- ues for the attribute Trigger.swImplPolicy are either STANDARD (in which case the Trigger processing does not use a queue) or QUEUED (in which case the process- ing of Triggers positively uses a queue). at the time when the contract phase generation is executed.(cid:99)() 111 of 1228 Document ID 62: AUTOSAR_CP_TPS_SoftwareComponentTemplate Software Component Template AUTOSAR CP R23-11 Please note that the value of Trigger.swImplPolicy is not the final word on the implementation of a queue for the specific Trigger. The integrator still has the power to overrule the application software developer’s verdict if applicable. For more information regarding the ability to connect different kinds of PortProto- types typed by a TriggerInterface to each other please refer to [constr_1204] and [constr_1205]. 4.2.5 Communication of Modes 4.2.5.1 Mode Switch Interface There are two distinctive use cases for the communication of modes via ports: 1. An actual mode transition can be communicated from a mode manager compo- nent to its client components to enforce a mode switch. 2. A request for a mode transition can be communicated from any component to a mode manager. AtpPrototype PortInterface ModeDeclarationGroupPrototype ModeSwitchInterface + swCalibrationAccess: SwCalibrationAccessEnum [0..1] ARElement AtpStructureElement AtpBlueprint Identifiable AtpBlueprintable ModeDeclaration AtpType UploadableDesignElement + value: PositiveInteger [0..1] ModeDeclarationGroup + onTransitionValue: PositiveInteger [0..1] (cid:1) (cid:16) (cid:25) (cid:2) (cid:17) (cid:26)(cid:19) (cid:3) (cid:18) (cid:4) (cid:2)(cid:19) (cid:20) (cid:5) (cid:3) (cid:4) (cid:20) (cid:2) (cid:6) (cid:6) (cid:14) (cid:7) (cid:9) (cid:7) (cid:3) (cid:2) (cid:21) (cid:3) (cid:3) (cid:7) (cid:27) (cid:7) (cid:9) (cid:8) (cid:20) (cid:22) (cid:9) (cid:6) (cid:10) (cid:7) (cid:9) (cid:7) (cid:16) (cid:2) (cid:13) (cid:12) (cid:3) (cid:2) (cid:12) (cid:7) (cid:8) (cid:13) (cid:7) (cid:23) (cid:9) (cid:14) (cid:12) (cid:15) (cid:20) (cid:7) (cid:23) (cid:24) (cid:20) +modeGroup 0..1 «isOfType» 0..1 +type {redefines atpType} +modeDeclaration «atpVariation,atpSplitable» 0..* +initialMode 0..1 Figure 4.8: Mode Switch Interface [TPS_SWCT_01087] Propagation of mode information (cid:100)For communicating a mode switch (i.e. the first use case), the Software-Component Template describes the con- cept of the communication of ModeDeclarationGroupPrototypes similar to the communication of VariableDataPrototypes but it uses a special type of PortIn- terface: the collections of ModeDeclarations that are required or provided by a SwComponentType are defined by means of ModeSwitchInterfaces used to type the PortPrototypes owned by the SwComponentType.(cid:99)(RS_SWCT_02030, RS_- SWCT_03203) This aspect is depicted in Figure 4.8. 112 of 1228 Document ID 62: AUTOSAR_CP_TPS_SoftwareComponentTemplate Software Component Template AUTOSAR CP R23-11
class CseCodeType(ARPrimitive):
    """AUTOSAR CseCodeType primitive type.

    Inherits deserialize() from ARPrimitive which automatically converts
    XML text content to the appropriate Python type based on python_type.
    """

    python_type: type = str
    """The underlying Python type for this primitive."""

    def __init__(self, value: Optional[str] = None) -> None:
        """Initialize CseCodeType.

        Args:
            value: The primitive value
        """
        super().__init__()
        self.value: Optional[str] = value
