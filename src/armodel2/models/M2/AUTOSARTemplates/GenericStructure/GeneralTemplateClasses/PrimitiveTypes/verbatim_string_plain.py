"""VerbatimStringPlain AUTOSAR primitive type.

References:
  - AUTOSAR_FO_TPS_GenericStructureTemplate.pdf (page 115)

JSON Source: packages/M2_AUTOSARTemplates_GenericStructure_GeneralTemplateClasses_PrimitiveTypes.primitives.json"""

from __future__ import annotations
from typing import TYPE_CHECKING, Optional
import xml.etree.ElementTree as ET

from armodel2.models.M2.AUTOSARTemplates.GenericStructure.GeneralTemplateClasses.PrimitiveTypes.ar_primitive import ARPrimitive

# This primitive represents a string in which white-space needs to be preserved. This primitive is applied in cases where xml:space attribute cannot be provided by the primitive type but needs to be provided by the container class. This is in particular the case in applications of [TPS_XMLSPR_00024]. Tags: xml.xsd.customType=VERBATIM-STRING-PLAIN xml.xsd.type=string xml.xsd.whiteSpace=preserve Table 4.68: VerbatimStringPlain 4.9 Formula Language This chapter details the introduction of a general purpose formula language. The for- mula language can be used in different processing steps in the methodology, e.g. XML- processors, C preprocessor, Modeling tools. Core features of formula language are: • The formula language always yields numerical. • It is formally defined in ANTLR [12]. • Provides well-defined extension points. • The formula language can handle: – numerical literals, string literals – values provided by references to autosar model element e.g. sysc, ecuc, supported references as specified in the meta-model 115 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 – commonly used operators +, −, etc. (see section 4.9.2.1) – hardcoded function sin, etc. (extension point, see section 4.9.2.2) – string - comparisons see [TPS_GST_00146], [TPS_GST_00147] – special values such as undefined [TPS_GST_00010] infinite [TPS_GST_00275] 4.9.1 Applying Formula Language Until Release 3 the AUTOSAR artifacts could not express dependencies, i.e. calculate the value of one parameter based on other parameter values, or define values based on variant information. Each of these use cases is represented as a specialization of the abstract meta-class FormulaExpression as shown in figure 4.13. «atpMixedString» FormulaExpression «atpMixedString» EcucParameterDerivationFormula «atpMixedString» CompuGenericMath EcucConditionFormula + level: PrimitiveIdentifier [0..1] «atpMixedString» TDEventOccurrenceExpressionFormula SwSystemconstDependentFormula FMFormulaByFeaturesAndAttributes FMFormulaByFeaturesAndSwSystemconsts «atpMixedString» BlueprintFormula Figure 4.13: Formula language class hierarchy [TPS_GST_00355] Specialization of FormulaExpression (cid:100)These specializations represent three kinds of extensions: • The applicable operands are specified as associations in the subclasses (see [TPS_GST_00001] for more details). The valid reference in the grammar be- low are taken from the role names in the meta-model. Maintaining the references as formal associations allows to retrieve dependencies even without parsing the formula expressions. 116 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 • Additional functions are represented by the specialization and documented in the context of the same (see [TPS_GST_00293] for more details). It is not possible to extend the language by further operators. • The particular application constrains the expected result. E.g. in Attribute- ValueVariationPoint, the result is given by the type of the variant attribute. Another example is swSyscond which expects a boolean result. (cid:99)() An example of applicable operands is given in figure 4.15. «atpMixedString» BlueprintFormula::BlueprintFormula FormulaExpression FormulaExpression FormulaExpression «atpMixedString» ECUCParameterDefTemplate:: VariantHandling:: TDEventOccurrenceExpression:: EcucConditionFormula SwSystemconstDependentFormula TDEventOccurrenceExpressionFormula Figure 4.14: Formula language family The formula language defined here is the core part of the specialization, blue part in figure 4.14. Please note that FormulaExpression is (cid:28)atpMixedString(cid:29) (see Chapter 2.3.1). Therefore one expression can e.g. be dependent on multiple SwSystem- consts. 117 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 «atpMixedString» FormulaExpression +sysc ARElement SwSystemconstDependentFormula AtpDefinition 0..1 {subsets atpReference} SwSystemconst +syscString 0..1 {subsets atpStringReference} AttributeValueVariationPoint ConditionByFormula + bindingTime: BindingTimeEnum [0..1] + bindingTime: BindingTimeEnum + blueprintValue: String [0..1] + sd: String [0..1] + shortLabel: PrimitiveIdentifier [0..1] AttributeValueVariationPoint IntegerValueVariationPoint AbstractEnumerationValueVariationPoint + base: Identifier [0..1] + enumTable: Ref [0..1] PositiveIntegerValueVariationPoint FloatValueVariationPoint UnlimitedIntegerValueVariationPoint BooleanValueVariationPoint TimeValueValueVariationPoint AbstractNumericalVariationPoint NumericalValueVariationPoint LimitValueVariationPoint + intervalType: IntervalTypeEnum [0..1] Figure 4.15: Formula depending on SwSystemconst 4.9.2 Formula Language Definition The connection between the formula and referenced meta-model objects act- ing as operands is established by associations in the meta-model and repre- sented in the grammar as rule named reference and stringReference (see [TPS_GST_00001]). Therefore FormulaExpressions are (cid:28)atpMixedString(cid:29)s when serialized in ARXML. The grammar for the expressions, however, is defined after the processing of the mixed strings by a XML Parser, i.e. they no longer contain any 118 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 XML-Tags, -Entities, -Comments, etc.. This is done to not "mimic" XML in the grammar but to focus on the expressions itself. The following rules shall be applied to come from the ARXML representation to the string that is then subject to the definition by the grammar: • XML-Entities are replaced by the UTF characters they stand for (e.g. "&lt;" is replaced by "<") • XML-Comments are removed • ARXML References are replaced by: – reference("‘{value of the DEST attribute}:{text content of the tag}") if they are subsets of the +/atpReference Association between FormulaEx- pression and Referrable – stringReference("{value of the DEST attribute}:{text content of the tag}") if they are subsets of the +/atpStringReference Association between FormulaExpression and Referrable E.g. consider the following ARXML snippet: <VARIATION-POINT> <SW-SYSCOND> defined(<SYSC-REF DEST="SW-SYSTEMCONST">SY_COUNT<SYSC-REF>) <!-- this is a comment --> &amp;&amp; <SYSC-REF DEST="SW-SYSTEMCONST">SY_COUNT<SYSC-REF> &lt; 10 </SW-SYSCOND> <VARIATION-POINT> The FormulaExpression is serialized in ARXML in the (cid:28)atpMixedString(cid:29) Tag <SW-SYSCOND>. It is transformed by the above rules into: defined(reference("SW-SYSTEMCONST:SY_COUNT") && reference("SW-SYSTEMCONST:SY_COUNT") < 10 This FormulaExpression is then considered as well-formed according to the syntax defined by the formula language grammar. Use case specific extensions may be applied by redefining particular token definitions according to [TPS_GST_00293]. [TPS_GST_00012] AUTOSAR Formula language (cid:100)The AUTOSAR formula language uses the following syntax described in Listing 4.18 defined according to [12].(cid:99)() grammar autosarFormulaLanguage; expr : atomExpr ; atomExpr : condExpr ; condExpr : orExpr (CondOperator orExpr AltOperator orExpr)? ; 119 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 orExpr : xorExpr (OrOperator xorExpr)* ; xorExpr : andExpr (XorOperator andExpr)* ; andExpr : bitOrExpr (AndOperator bitOrExpr)* ; bitOrExpr : bitXorExpr (BitOrOperator bitXorExpr)* ; bitXorExpr : bitAndExpr (BitXorOperator bitAndExpr)* ; bitAndExpr : compEqExpr (BitAndOperator compEqExpr)* ; compEqExpr : compExpr (CompEqOperator compExpr)* ; compExpr : shiftExpr (CompOperator shiftExpr)* ; shiftExpr : sumExpr (ShiftOperator sumExpr)* ; sumExpr : mulExpr (SumOperator mulExpr)* ; mulExpr : powExpr (MulOperator powExpr)* ; powExpr : unaryExpr (PowOperator unaryExpr)? ; unaryExpr : unaryOperator? atom; atom : DecIntegerLiteral | reference | BooleanLiteral | HexIntegerLiteral | OctIntegerLiteral | BinIntegerLiteral | DecimalLiteral | DoubleLiteral | ArgumentOperand | DefinedFuncName LPAREN (reference | stringReference) RPAREN | StringFuncName LPAREN stringArg COMMA stringArg RPAREN | BinaryFuncName LPAREN atomExpr COMMA atomExpr RPAREN | UnaryFuncName LPAREN atomExpr RPAREN | Keyword | (LPAREN atomExpr RPAREN) // Here the supported extension points are listed: // Depending on which of the extension points are defined in a // spcialisation of the formula language, the following one, // two or all of the following alternatives are added to this rule: // | ExtBinaryFuncName LPAREN atomExpr COMMA atomExpr RPAREN // | ExtUnaryFuncName LPAREN atomExpr RPAREN // | ExtKeyword // end of extension points ; stringArg : stringReference | StringLiteral ; 120 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 unaryOperator : SumOperator | OtherUnaryOperator ; //-------------------------------------------------------------------- // these rules represent the reference to operands // in an XML-Arttifact, this is represented as XML-Artifact // // Applicable RefFuncNames depend on the associations in the // particular specialization of FormulaLanguage in the // metamodel // see [TPS_GST_00001] stringReference : StringReferenceFuncName LPAREN StringLiteral RPAREN ; reference : ReferenceFuncName LPAREN StringLiteral RPAREN ; // argumentOperand is valid only in formula derived from CompuGenericMath ArgumentOperand : ’X’ (’1’ .. ’9’)(’0’ .. ’9’)* ; // Tokens OrOperator : ’||’; XorOperator : ’^^’ ; AndOperator : ’&&’; BitOrOperator : ’|’; BitXorOperator : ’^’; BitAndOperator : ’&’; CompEqOperator : ’==’ | ’!=’; CompOperator : ’<=’ | ’<’ | ’>=’ | ’>’ ; ShiftOperator : ’<<’ | ’>>’ ; SumOperator : ’+’ | ’-’ ; OtherUnaryOperator : ’!’ | ’~’ ; MulOperator : ’*’ | ’/’ | ’%’ ; PowOperator : ’**’ ; CondOperator : ’?’; AltOperator : ’:’; 121 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 DefinedFuncName : ’defined’ ; StringFuncName : ’streqcs’ | ’streqci’; UnaryFuncName : ’round’ | ’ceil’ | ’floor’ | ’abs’ | ’log’ | ’exp’ | ’sin’ | ’cos’ | ’asin’ | ’acos’ | ’atan’ | ’sinh’ | ’cosh’ | ’tan’ | ’tanh’ | ’sqrt’ | ’log10’ | ’sgn’ ; ReferenceFuncName : ’reference’ ; StringReferenceFuncName : ’stringReference’ ; BinaryFuncName : ’max’ | ’min’ | ’pow’ ; Keyword : ’epsilon’ | ’undefined’ ; ////////////////////////////////////////////////////////////////// //Here the definitions for the extenstion points would be included ////////////////////////////////////////////////////////////////// BooleanLiteral : ’true’ | ’false’ ; LPAREN : ’(’ ; RPAREN : ’)’ ; COMMA : ’,’ ; //------------------------------------------------------------------------------- DecIntegerLiteral : ’0’ | (’1’..’9’)(’0’..’9’)* ; HexIntegerLiteral : ’0’ (’x’ | ’X’) ((’0’..’9’) | (’a’..’f’) | (’A’..’F’))+ ; OctIntegerLiteral : ’0’(’0’..’7’)+ ; 122 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 BinIntegerLiteral : ’0’ (’b’ | ’B’) (’0’ ..’1’)+ ; DecimalLiteral : (’0’? ’.’ (’0’..’9’)+) | ((’1’..’9’)(’0’..’9’)* (’.’ (’0’..’9’)*)) ; DoubleLiteral : (((’0’? ’.’ (’0’..’9’)+) | ((’1’..’9’)(’0’..’9’)* (’.’ (’0’..’9’)*)?)) (’e’ | ’E’) (’+’ | ’-’)? (’0’..’9’)+) | ’NaN’ | ’INF’ ; // The next rule defines StringLiterals as double quoted sequences of // (almost) arbitrary characters with the backslash as escape character. // Please notice that the tilde is used in the ANTLR syntax to denote // negation and it is necessary to escape the backslash to match itself. StringLiteral : ’"’ ((~(’"’|’\\’) | ’\\’ ~(’\\’) | ’\\\\’)*) ’"’ ; WS : (’ ’ | ’\t’ | ’\r’ | ’\n’ )+ {$channel=HIDDEN;} ; Listing 4.18: AUTOSAR Formula language 4.9.2.1 Operators in arithmetic expressions The following operators are supported in arithmetic expressions: • [TPS_GST_00111] Negation Operator (cid:100)(yields boolean, bit-wise negation)(cid:99)() Symbol: !, ∼ Return Types see [TPS_GST_00039] • [TPS_GST_00112] Exponentiation Operator (cid:100)yields operand 1 power operand 2(cid:99)() Symbol: ** Return Types see [TPS_GST_00035] • [TPS_GST_00113] Multiplicative Operator / division (cid:100)yields Multiplication, di- vision, modulo(cid:99)() Symbol: *, /, % Return Types see [TPS_GST_00035] • [TPS_GST_00114] Additive Operator (cid:100)Yields Addition, subtraction, sign(cid:99)() Symbol: +, - Return Types see [TPS_GST_00034] • [TPS_GST_00115] Shift Operator (cid:100)Yields bit-wise shift (left, right) note that the ends are filled with "0".(cid:99)() Symbol: <<,>> Return Types see [TPS_GST_00037] • [TPS_GST_00116] Ranking Operator (cid:100)Yields comparison: less than, less than or equal to, greater than, greater than or equal to(cid:99)() Symbol: <, <=, >, >= Return Types see [TPS_GST_00036] • [TPS_GST_00117] Comparison: equality (cid:100)Yields equal, unequal to(cid:99)() Symbol: ==, != Return Types see [TPS_GST_00036] 123 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 • [TPS_GST_00118] Bit-wise AND (cid:100)Yields the bit wise and of the operators(cid:99)() Symbol: & Return Types see [TPS_GST_00037] • [TPS_GST_00119] Bit-wise XOR (cid:100)Yields the bit wise xor of the operators(cid:99)() Symbol: ˆReturn Type see [TPS_GST_00037] • [TPS_GST_00120] Bit-wise OR (cid:100)Yields the bit wise or of the operators(cid:99)() Symbol: |Return Types see [TPS_GST_00037] • [TPS_GST_00121] Boolean AND (cid:100)Yields a boolean AND with operand value 0 -> false, others -> true(cid:99)() Symbol: && Return Types see [TPS_GST_00036] • [TPS_GST_00122] Boolean XOR (cid:100)Yields a boolean XOR with operand value 0 -> false, others -> true(cid:99)() Symbol: ˆˆReturn Types see [TPS_GST_00036] • [TPS_GST_00123] Boolean OR (cid:100)Yields a boolean OR with operand value 0 -> false, others -> true(cid:99)() Symbol: ||Return Types see [TPS_GST_00036] 4.9.2.2 Mathematical functions in arithmetic expressions The following mathematical functions are supported in arithmetic expressions: • [TPS_GST_00124] Round Function (cid:100)This rounds positive and negative num- bers to the nearest whole number. Note that when processing such expressions, that round is defined for the value ranges -2147483648 to +4294967295.(cid:99)() Function: round Param.: 1 Type of result: integer • [TPS_GST_00125] Round Up Function (cid:100)This rounds positive and negative numbers up to the next whole number. Note that when processing such expres- sions, that ceil is defined for the value ranges -2147483648 to +4294967295.(cid:99) () Function: ceil Param.: 1 Type of result: integer • [TPS_GST_00126] Round Down Function (cid:100)This rounds positive and neg- ative numbers down to the next whole number. Note that when processing such expressions, that floor is defined for the value ranges -2147483648 to +4294967295.(cid:99)() Function: floor Param.: 1 Type of result: integer • [TPS_GST_00127] Absolute Value (cid:100)This yields the absolute value of the operand.(cid:99)() Function: abs Param.: 1 Type of result: like operand • [TPS_GST_00128] Natural Logarithm (cid:100)This yields the natural logarithm (base e) of the argument.(cid:99)() Function: log Param.: 1 Type of result: float 124 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 • [TPS_GST_00129] Decimal Logarithm (cid:100)This yields the logarithm base 10 - provided for A2L 1.6.(cid:99)() Function: log10 Param.: 1 Type of result: float • [TPS_GST_00130] Square Root (cid:100)This yields the square root - provided for A2L 1.6.(cid:99)() Function: sqrt Param.: 1 Type of result: float • [TPS_GST_00131] Sinus (cid:100)This yields sinus - provided for A2L 1.6.(cid:99)() Function: sin Param.: 1 Type of result: float • [TPS_GST_00132] Arcus Sinus (cid:100)This yields arcus sinus - provided for A2L 1.6.(cid:99) () Function: asin Param.: 1 Type of result: float • [TPS_GST_00133] Cosinus (cid:100)This yields cosinus - provided for A2L 1.6.(cid:99)() Function: cos Param.: 1 Type of result: float • [TPS_GST_00134] Arcus Cosinus (cid:100)This yields arcus cosinus - provided for A2L 1.6.(cid:99)() Function: acos Param.: 1 Type of result: float • [TPS_GST_00135] Sinus Hyperbolicus (cid:100)This yields sinus hyperbolicus - pro- vided for A2L 1.6.(cid:99)() Function: sinh Param.: 1 Type of result: float • [TPS_GST_00136] Cosinus Hyperbolicus (cid:100)This yields cosinus hyperbolicus - provided for A2L 1.6.(cid:99)() Function: cosh Param.: 1 Type of result: float • [TPS_GST_00137] Tangens (cid:100)This yields tangens - provided for A2L 1.6.(cid:99)() Function: tan Param.: 1 Type of result: float • [TPS_GST_00138] Arcus Tangens (cid:100)This yields arcus tangens - provided for A2L 1.6.(cid:99)() Function: atan Param.: 1 Type of result: float • [TPS_GST_00139] Tangens Hyperbolicus (cid:100)This yields tangens hyperbolicus - provided for A2L 1.6.(cid:99)() Function: tanh Param.: 1 Type of result: float • [TPS_GST_00140] Exponential (cid:100)This yields exponential function (base e).(cid:99)() Function: exp Param.: 1 Type of result: float • [TPS_GST_00141] Is Defined (cid:100)This checks whether the reference given as the argument is defined.(cid:99)() Function: defined Param.: 1 Type of result: 0 or 1 • [TPS_GST_00142] Signum (cid:100)This yields signum, result is one of -1, 0, +1.(cid:99)() Function: sgn Param.: 1 Type of result: integer 125 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 • [TPS_GST_00143] Maximum Value (cid:100)This finds the maximum value of the argu- ments.(cid:99)() Function: max Param.: 2 Type of result: depends on operands • [TPS_GST_00144] Minium Value (cid:100)This finds the minimum value of the argu- ments.(cid:99)() Function: min Param.: 2 Type of result: depends on operands • [TPS_GST_00145] Power Function (cid:100)This yields argument 1 power argument 2 - provided for A2L 1.6. This is equivalent to [TPS_GST_00112].(cid:99)() Function: pow Param.: 2 Type of result: depends on arguments Result type follows [TPS_GST_00035]. • [TPS_GST_00146] Case Sensitive String Compare (cid:100)This compares two strings in case sensitive manner.(cid:99)() Function: streqcs Param.: 2 Type of result: 0 or 1 • [TPS_GST_00147] Non Case Insensitive String Compare (cid:100)This compares two strings in non case sensitive manner.(cid:99)() Function: streqci Param.: 2 Type of result: 0 or 1 4.9.2.3 Implementation details of a Formula Processor The following implementation details apply: • [TPS_GST_00001] Connection between Formula and Model Elements (cid:100)The formula language mentioned above has production rules (reference, stringReference) which are defined as stringReference : ’stringReference’ LPAREN StringLiteral RPAREN; reference : ’reference’ LPAREN StringLiteral RPAREN; This production indicates, that at this point, a reference to a model element needs to be resolved. It is not allowed to accept AUTOSAR artifacts which contain such a textual representation.(cid:99)() • [TPS_GST_00293] Use Case Specific Extension of Formula Language (cid:100)A use case specific extension is indicated in the meta-model by a specialization of FormulaExpression. The semantics of the extension is specified in the context of this specialization as a fragment of an ANTLR [12] specification redefining the following Tokens: – ExtKeyword - this provides additional keywords similar to epsilon – ExtUnaryFuncName - this provides additional names for unary functions – ExtBinaryFuncName - this provides additional names for binary functions 126 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 It is not possible to extend the formula language by additional operators.(cid:99)() Thus the list of functions in chapter 4.9.2.2 is extended. An example for the definition of additional Keywords based on an unary function is given in Listing 4.19. ExtUnaryFuncName : ’TIMEX_value’ | ’TIMEX_occurs’ | ’TIMEX_hasOccurred’ | ’TIMEX_timeSinceLastOccurrence’ | ’TIMEX_angleSinceLastOccurrence’ ; Listing 4.19: AUTOSAR Formula language extension • [TPS_GST_00015] result of reference/stringReference (cid:100) – reference shall yield a numerical / boolean value. – stringReference shall yield a string value. (cid:99)() • [TPS_GST_00002] aborting logical expressions (cid:100)The calculation of expres- sions with boolean AND or OR is aborted if the first operand has produced a result so that the total result cannot be changed anymore by the second operand (as in C).(cid:99)() Note: This is useful e.g. in the context of SwSystemconstDependentFormula, a specialization of the formula language. This behavior gives meaningful results in expressions such as: defined(reference("SW-SYSTEMCONST:SY_COUNT")) && reference("SW-SYSTEMCONST:SY_COUNT") > 1 since here, if SY_COUNT is not defined, the check for "> 1" is not carried out and an unwanted error message is thus avoided. • [TPS_GST_00003] true and false (cid:100)Like in C a integer "0" respectively floating point "0.0" and "-0.0" are interpreted as false. Every other value is treated as true within boolean expressions. The language also provides the literals "true" yielding 1 respectively "false" yielding 0 to express literal boolean values in expressions.(cid:99)() It is strongly recommended not to apply the Boolean operations ||, &&,ˆˆ, ==, != to floating-point values. Caused by the limited ability of float operands to hold exact integer (in the mathematical meaning) numbers the result of these operations may have (as implementation specifics have a huge impact here) values that are hard to predict. 127 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 • [TPS_GST_00004] Priority of Operations (cid:100) The priority rules of C++1 apply and are modeled in the grammar: multiplica- tion and division take precedence over addition and subtraction. The exponent operator (**) has priority over these other mathematical operators. The unary minus has greater precedence than all other operators. For a complete list of the priorities please refer to [13]. Example: – -2**3 becomes -8 = (-2)**3 – -log(2.718281828)**2 corresponds to (-log(2.718281828))**2 and therefore is equal to +1. (cid:99)() • [TPS_GST_00005] left-to-right evaluation (cid:100)Binary operators shall be evaluated from left to right (left-to-right associativity). For example 2 == 2 == 2 shall be evaluated as (2 == 2) == 2.(cid:99)() • [TPS_GST_00006] Associativity of XOR (cid:100)Boolean XOR operatorˆˆis an addi- tional operator which has no counterpart in C. The result of a boolean XOR is "1" if one of the operands is interpreted as false and the other as true. The result of a boolean XOR is "0" if both operands have the same value independent of whether the value is true or false. Other than boolean AND (&&) and boolean OR (||), boolean XOR always evaluates both operands. This is because the result of a boolean XOR cannot be determined by only evaluating e.g. the first operand. Hint: In hardware circuits sometimes an XOR gate with more than two inputs is used. For such a hardware XOR gate the output is "1" if and only if one of the inputs is "1" and all other inputs are "0". The XOR operator within arithmetic expressions is a binary operator and therefore behaves different than hardware XOR gates. This means in particular that according to left-to-right associativity e.g. 1ˆˆ1ˆˆ1 is interpreted as (1ˆˆ1)ˆˆ1 which yields "1".(cid:99)() • [TPS_GST_00007] Shift operation (cid:100) When the shift operation is performed, the first or the last bit (depending on the direction of the shift) is filled with "0". Shift left means that the bits are shifted towards the higher values. Shift right means that the bits are shifted towards the lower values. Shift is performed as long as we are in the range defined by [TPS_GST_00008](cid:99) () Implementers shall apply a mask on the intended size number of bits on the result. For example if 0b1111 « 1 shall still yield 4 bits, then user shall write (0b1111 « 1) & 0b1111 1Note that XOR is not defined in C++. 128 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 to get the intended result of 0b1110. Without the mask, the result would be 0b11110 which is 5 bit. Example based on 32 bit integer implementation of the formula processor (note that not all leading zero digits are shown): – 0b0001 << 1 returns 0b00010 – 0b1111 >> 1 returns 0b0111 – 0b1111 << 1 returns 0b11110 – 0b1111 << 2 returns 0b111100 • [TPS_GST_00008] Types in Formula Expressions (cid:100) The type of an arithmetic expression is one of – Integer in the range (32 bit implementation) 0x80000000 .. 0xffffffff -2147483648 .. +4294967295 respectively (in a 64 bit implementation) 0x8000000000000000 .. +0xffffffffffffffff -9223372036854775808 .. +18446744073709551615 – Float (internally represented by double) (cid:99)() For the result type of a function or operand see 4.9.2.4. Note: The ranges of the 32-bit implementation are the set union of signed INT (-2147483648 .. 2147483647) and unsigned INT (0 .. 4294967295) resulting in (-2147483648 .. 4294967295). The same procedure is applied for the 64-bit implementation. • [TPS_GST_00359] Handling of the Sign (cid:100) In consequence of [TPS_GST_00008], implementations of a formula processor need to provide an extra handling of the sign in case of integer values. -2147483648 < value < 0 => signed INT (sign "-") -2147483648 < value < 2147483647 => signed INT (sign "-" or "+") -0 => signed INT (sign "-") +0 => signed INT (sign "+") 0 < value < 2147483647 => unsigned INT 2147483647 < value < 4294967295 => unsigned INT. (cid:99)() • [TPS_GST_00009] Keyword ’epsilon’ (cid:100) epsilon represents an implementation specific constant intended to support the comparison of float values. It represents the smallest increment which can be expressed by the given implementation. 129 of 535 Document ID 202: AUTOSAR_FO_TPS_GenericStructureTemplate Generic Structure Template AUTOSAR FO R23-11 For example instead of comparing a float with zero, one should use abs(sysc(x)) < epsilon ? 0 : 1 (cid:99)() • [TPS_GST_00276] Power of Null (cid:100) pow(0, 0) respectively 0**0 is undefined and shall raise an error (see also [TPS_GST_00014]). (cid:99)() • [TPS_GST_00010] Keyword undefined (cid:100) undefined represents a sub term which is undefined. It is subject to be replaced in further process steps. The main purpose is to denote blueprints of expressions. The result of undefined is the same as an undefined operand. Usually it yields a runtime error. The following expressions hold true: defined(undefined) = false true && undefined = error false && undefined = false undefined = error And consequently for OR it is true || undefined = true false || undefined = error (cid:99)() • [TPS_GST_00275] Float Literals INF, NaN (cid:100)In order to maintain consistency with Float, formula expressions also supports the special float literals INF and NaN. The support of these literals is in particular: – INF is allowed only in the context of operators "==", "!=", unary "-", result of condExpr – NaN is allowed only in the context of operators "==", "!=", result of cond- Expr – INF, NaN can only be obtained by literal specification (e.g. in a SwSystem- constValue) but not as the result of an arithmetic operation (In particular [TPS_GST_00014] is not affected by these literals). (cid:99)()
class VerbatimStringPlain(ARPrimitive):
    """AUTOSAR VerbatimStringPlain primitive type.

    Inherits deserialize() from ARPrimitive which automatically converts
    XML text content to the appropriate Python type based on python_type.
    """

    python_type: type = str
    """The underlying Python type for this primitive."""

    def __init__(self, value: Optional[str] = None) -> None:
        """Initialize VerbatimStringPlain.

        Args:
            value: The primitive value
        """
        super().__init__()
        self.value: Optional[str] = value
